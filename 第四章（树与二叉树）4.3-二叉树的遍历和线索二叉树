/*
4.3.3，二：3
后序遍历二叉树的非递归算法。
*/
//还不是很理解
#include<cstdio>
#include<cstdlib>

struct node{
	int data;
	struct node *left;
	struct node *right;
};
const int SIZE=17;
int arr[SIZE]={0,
						110,
						0,             30,
						0,     0,     5,     9,
						0,0,0,0,  0,40,10,0  };
node* createTree(int index){
	printf("\nnode %d,",index);
	if(!arr[index]){
		printf("NULL\n");
		return NULL;
	}
	node *p=new node;
	printf("data:%d\n",p->data=arr[index]);
	printf("left of node %d",index);
	p->left=createTree(index*2);
	printf("right of node %d",index);
	p->right=createTree(index*2+1);
	return p;
}
//后续遍历递归算法
void recursive_postorder_traversal(node *head){
	if(head){
		recursive_postorder_traversal(head->left);
		recursive_postorder_traversal(head->right);
		printf("%d, ",head->data);
	}
}
//后续遍历非递归算法
void non_recursive_postorder_traversal(node *head){
	node* stack[SIZE];//堆栈存储的是结点的地址。
	int i;
	for(i=0;i<SIZE;i++){
		stack[i]=NULL;
	}
	int sp=-1;
	node *pre=head,*p=head;
	stack[++sp]=head; 
	while(sp!=-1){
		while(p->left){//左孩子不存在则结束循环，若存在则将这个左孩子压入堆栈，并让p指向左孩子。
			pre=p;
			p=p->left;
			stack[++sp]=p;
		}
		p=stack[sp--];
		while(!p->right||p->right==pre){//如果右结点不存在，则打印当前结点，pre记录此次访问，弹出栈顶结点
			printf("%d, ",p->data);
			pre=p;
			if(sp==-1){
				return;
			}
			p=stack[sp--];
		}
		//经过上面的循环，p->right只有存在且未被访问一种情况。只要
		stack[++sp]=p;
		pre=p;
		p=p->right;
		stack[++sp]=p;
	}
}

int main(){
	node *head=createTree(1);
	printf("\nprint tree:");
	recursive_postorder_traversal(head);
	printf("\nprint tree:");
	non_recursive_postorder_traversal(head);
	return 0;
}

/*
4.3.3，二：4
二叉树自上而下、从右到左的层次遍历算法。
*/
#include<cstdio>
#include<cstdlib>

struct node{
	int data;
	struct node *left;
	struct node *right;
};
const int SIZE=17;
int arr[SIZE]={0,
		110,
		70,            30,
		90,    0,     5,     9,
		1,2,   0,0,  0,40,10,0  };
node* createTree(int index){
	if(!arr[index]){
		return NULL;
	}
	node *p=new node;
	p->left=createTree(index*2);
	p->right=createTree(index*2+1);
	return p;
}
void invertLevel(node *root){
	//建立及初始化栈
	node* stack[SIZE];
	int sp=-1;
	//建立及初始化队列
	node* queue[SIZE];
	int front=0,rear=0;
	
	queue[rear]=root;
	rear=(rear+1)%SIZE;
	node *p;
	while(rear!=front){//队列非空，则弹出队首结点，将它的孩子结点加入队尾。该结点压栈。
		p=queue[front];
		front=(front+1)%SIZE;
		if(p->left){
			if((rear+1)%SIZE!=front){
				queue[rear]=p->left;
				rear=(rear+1)%SIZE;
			}
		}
		if(p->right){
			if((rear+1)%SIZE!=front){
				queue[rear]=p->right;
				rear=(rear+1)%SIZE;
			}
		}
		stack[++sp]=p;
	}
	while(sp!=-1){
		printf("%d, ",stack[sp--]->data);
	}
}

int main(){
	node *root=createTree(1);
	printf("\nprint tree:");
	invertLevel(root);
	return 0;
}

/*
4.3.3，二：5
二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。
*/
#include<cstdio>
#include<cstdlib>
struct node{
	int data;
	struct node *left;
	struct node *right;
};
const int SIZE=21;
int arr[SIZE]={0,
		110,
		70,            30,
		90,    0,     5,     9,
		1,2,   0,0,  0,40,10,0,
		0,0,0,13  };
node* createTree(int index){
	if(!arr[index]){
		return NULL;
	}
	node *p=new node;
	p->left=createTree(index*2);
	p->right=createTree(index*2+1);
	return p;
}
void BTdepth(node *root){
	//建立及初始化队列
	node* queue[SIZE];
	int front=0,rear=0;
	
	queue[rear]=root;
	rear=(rear+1)%SIZE;
	int level=0;
	node *p,*last=root,*nextlast;
	while(rear!=front){//队列非空，则弹出队首结点，将它的孩子结点加入队尾。该结点压栈。
		p=queue[front];
		front=(front+1)%SIZE;
		//下一层孩子压栈时，只要发现有孩子就把它设置为下一层最后一个结点nextlast
		if(p->left){
			if((rear+1)%SIZE!=front){
				queue[rear]=p->left;
				rear=(rear+1)%SIZE;
			}
			nextlast=p->left;
		}
			if((rear+1)%SIZE!=front){
				queue[rear]=p->right;
				rear=(rear+1)%SIZE;
			}
			nextlast=p->right;
		}
		if(p==last){//访问到这一层最后一个结点时，才可以改动last，将它置为下一层最后一个结点nextlast，若下一层没有最后一个结点，nextlast的值和last的值应该是相等的。
			level++;
			last=nextlast;
		}
	}
	printf("%d\n",level);
}

int main(){
	node *root=createTree(1);
	printf("depth:");
	BTdepth(root);
	return 0;
}

/*
4.3.3，二：6
数组a，b分别存储先序遍历和中序遍历的序列，编写算法建立该二叉树的二叉链表。
*/
#include<cstdio>
#include<cstdlib>
struct node{
	int data;
	struct node *left;
	struct node *right;
};

const int SIZE=11;
int a[SIZE]={4,5,1,9,10,13,14,6,7,100,20};
int b[SIZE]={9,1,5,10,13,4,6,14,100,7,20};

node* create(int a1,int a2,int b1,int b2){
	if(a1>a2)return NULL;
	
	node *p=new node;//分割出的子树的先序序列第一个元素a[a1]为当前子树的根
	p->data=a[a1];
	if(a1==a2){//先序遍历只有一个元素，即当前子树只有一个元素，左右孩子直接置为NULL，返回p
		p->left=NULL;
		p->right=NULL;
	}else{//先序遍历不只一个元素，则在中序序列b1-b2中寻找先序序列第一个元素a1在中序序列中的位置，递归获得左右孩子的结点值。
		int tmp=b1;
		while(tmp<=b2&&b[tmp]!=a[a1]){
			tmp++;
		}
		if(tmp>b2){
			printf("somewhere wrong!");
			return NULL;
		}
		p->left=create(a1+1,a1+tmp-b1,b1,tmp-1);//最后的tmp-1写成tmp好像也没影响，可能因为判断是否return NULL是根据a1和a2。写成tmp具体有什么副作用还没想清楚。
		p->right=create(a1+tmp-b1+1,a2,tmp+1,b2);
	}
	return p;
}
void print(node *head){
	if(head){
		printf("%d, ",head->data);
		print(head->left);
		print(head->right);
	}
}
void print2(node *head){
	if(head){
		print2(head->left);
		printf("%d, ",head->data);
		print2(head->right);
	}
}
int main(){
	node *root=create(0,10,0,10);
	printf("print:");
	print(root);
	printf("\nprint2:");
	print2(root);
	return 0;
}

/*
4.3.3，二：7
判别给定二叉树是不是完全二叉树。
*/
//和答案思路不同，且没有运行，不能保证正确。
struct node{
	int data;
	struct node *left;
	struct node *right;
};
int complete(node *p,int size){
	if(!p){
		return 1;//空树为满二叉树！！！！！！！！！！！！！！！！！
	}
	int stack[size],sp=-1;
	int flag=1;
	
	stack[++sp]=p;
	while(sp!=-1){
		p=stack[sp--];
		//遇到一个孩子为空的结点则将flag置为2，此后如果当前结点还有其他右孩子，或其他结点还有孩子，则直接返回0。
		if(p->left){//左孩子存在
			if(flag==1){//之前结点都有两个孩子
				stack[++sp]=p->left;
			}else return 0;//之前结点不全为两个孩子，非完全二叉树
		}else if(flag!=2){//flag不为2，才需要重新给flag赋值
			flag=2;
		}
		if(p->right){
			if(flag==1){
				stack[++sp]=p->right;
			}else return 0;
		}else if(flag!=2){
			flag=2;
		}
	}
	return 1;
}

/*
4.3.3，二：8
计算二叉树双分支结点的个数。
*/
struct node{
	int data;
	struct node *left;
	struct node *right;
};
int n=0;
int complete(node *p){
	if(p){
		if(p->left&&p->right){
			n++;
		}
		complete(p->left);
		complete(p->right);
	}
}

